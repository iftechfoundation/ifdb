<?php
include_once "session-start.php";

// make sure we process any persistent login state
include_once "login-persist.php";
$userid = checkPersistentLogin();

include_once "pagetpl.php";
include_once "util.php";
include_once "dbconnect.php";
$db = dbConnect();

$id = get_req_data('id');
$qid = mysql_real_escape_string($id, $db);

$xml = isset($_REQUEST['xml']);

// cache the IF Archive mirror mapping, if any
global $mirrorIDPref, $mirrorUrlPref;
include "mirrorUrl.php";


$urlToOsMap = array(
    "Windows" => 'return str_replace("/", "\\\", $s);',
    "MSDOS" => 'return str_replace("/", "\\\", $s);',
    "MacOS" => 'return urlToMac($s);');

// Macs don't really have directory paths in the Unix style; they have
// the same concept, but it's normally hidden away in internal structures
// rather than serialized into a string format for the user to see.
// Macs *do* have a canonical serialization - the ":" path notation -
// but it's basically only for use by programmers, not users.  Since
// most users aren't familiar with that notation, we won't use it.
// Instead, construct a pseudo-path notation whose meaning should be
// intuitively obvious to most users, even if it's not canonical:
// write a/b/c as  a > b > c.
function urlToMac($s)
{
    $idx = strpos($s, '/');
    if ($idx == false)
        return $s;
    else if ($idx == 0)
        $s = substr($s, 1);
    return str_replace('/', ' &gt; ', $s);
}

function sendXmlContents($contents)
{
    // if it's a string, break it up by line
    if (gettype($contents) == 'string') {
        // split by line
        $contents = explode("\n", $contents);

        // if it's a single line, just send it immediately and we're done
        if (count($contents) == 1) {
            echo $contents[0] . "\n";
            return;
        }
    }

    // send each line recursively, so we break up any multi-line element
    foreach ($contents as $l)
        sendXmlContents($l);
}

function sendXml($contents)
{
    ini_set("default_charset", "ISO-8859-1");
    header("Content-Type: text/xml");

    echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        . "<autoinstall xmlns=\"http://ifdb.org/xmlns/autoinstall\">\n";

    sendXmlContents($contents);

    echo "</autoinstall>";
}

function errorPage($errId, $errTitle, $errMsg)
{
    global $xml;

    if ($xml) {
        sendXml("<error>\n"
                . "  <id>$errId</id>\n"
                . "  <message>$errMsg</message>\n"
                . "</error>");
    } else {
        pageHeader("Download Adviser");
        echo "<h1>$errTitle</h1><p>$errMsg";
        pageFooter();
    }
    exit();
}

// make sure we can find the game
$result = mysql_query(
    "select title, author, version from games where id='$qid'", $db);
if (mysql_num_rows($result) == 0) {
    errorPage("GAME NOT FOUND", "Game Not Found",
              "No database entry was found for the specified game.");
}

$title = htmlspecialcharx(mysql_result($result, 0, "title"));
$author = htmlspecialcharx(mysql_result($result, 0, "author"));
$version = htmlspecialcharx(mysql_result($result, 0, "version"));

// if we're in XML mode, we need the IFID list
$ifidsXml = "";
if ($xml) {
    // query the IFID list
    $result = mysql_query("select ifid from ifids where gameid='$qid'", $db);
    for ($ifids = array(), $i = 0 ; $i < mysql_num_rows($result) ; $i++)
        $ifids[] = htmlspecialcharx(mysql_result($result, 0, "ifid"));

    // turn it into XML
    $ifidsXml = implode("\n", array_map(
        create_function('$x', 'return "<ifid>$x</ifid>";'), $ifids));
}

// presume we want executables if available, as they're easier to deal
// with for novice users
$noExes = $noInstallers = 0;

// If we're logged in, start with the default parameters from the user's
// profile.
$osid = "";
if ($userid) {
    $result = mysql_query("select defaultos, defaultosvsn, noexedownloads
        from users where id = '$userid'", $db);
    list($osid, $osvsn, $noExes) = mysql_fetch_row($result);
}

// if there's an explicit OS selection in the session, use that, overriding
// what's in the profile
if (isset($_SESSION['download_adviser_state'])) {
    list($osid, $osvsn, $noExes) =
        explode(".", $_SESSION['download_adviser_state']);
}

// If we have explicit request parameters for the OS and other parameters,
// apply them - these override the profile and session defaults, so we
// intentionally waited to apply these until after loading all those sources.
if (isset($_REQUEST['os'])) {
    // get the OS ID and optional version ID
    $osinfo = explode(".", get_req_data('os'), 2);
    if (count($osinfo) == 1)
        $osinfo[1] = "";
    list($osid, $osvsn) = $osinfo;

    // if this is an XML request, the OS is given by an external ID -
    // we need to look it up to convert it into an internal key
    if ($xml) {
        // look up the OS
        $osid = mysql_real_escape_string($osid, $db);
        $osvsn = mysql_real_escape_string($osvsn, $db);
        $result = mysql_query(
            "select id from operatingsystems where externid='$osid'", $db);
        if (mysql_num_rows($result) == 0) {
            errorPage("INVALID OS", "Invalid OS ID",
                      "The specified operating system is not "
                      . "valid. (This indicates a problem with the network "
                      . "request or with the client software.)");
        }
        $osid = mysql_result($result, 0, "id");

        if ($osvsn != "") {
            $result = mysql_query(
                "select vsnid from osversions where externid='$osvsn'", $db);
            if (mysql_num_rows($result) == 0) {
                errorPage("INVALID OS", "Invalid OS ID",
                          "The specified operating system is not "
                          . "valid. (This indicates a problem with the "
                          . "network request or with the client software.)");
            }
            $osvsn = mysql_result($result, 0, "vsnid");
        }
    }
}
if (isset($_REQUEST['noexes']))
    $noExes = $_REQUEST['noexes'];

// if there's no OS set already, look for an OS from the browser ID string
if ($osid == "") {
    $val = browser_os_detect();
    if ($val)
        list ($osid, $osvsn) = $val;
}

// If there's no OS setting (either from the profile defaults or the
// request parameters), they need to choose one before we can proceed.
if ($osid == "") {
    // this isn't allowed if it's an XML request
    if ($xml) {
        errorPage("MISSING OS", "OS Parameter Missing",
                  "Invalid network request - the OS parameter is missing.");
    } else {

        pageHeader("Download Adviser");

        // they need to choose an operating system before we can proceed
        echo "<h1>Download Adviser for <i>$title</i></h1>

            <a href=\"viewgame?id=$id\">Return to the game's home page</a><p>

            <form method=\"get\" action=\"dladviser\" name=\"getOS\">
            <p>Please select the operating system that you'll be using
            to play this game, so that we can provide custom advice
            for your system.
            <p><span class=notes><i>If you set a preferred OS in your
            <a href=\"editprofile\">profile</a>, the Download Adviser
            won't have to ask you each time which system to use.</i></span>
            <p>";

        showOSPopup($db, "os", "", 0);
        echo " <input type=image src=\"/img/blank.gif\" name=\"setOS\" "
            . "id=\"dla-setos-1\" class=\"go-button\">"
            . "<input type=hidden name=\"id\" value=\"$id\">"
            . "</form>";

        pageFooter();
    }

    // no need to go on from here
    exit();
}

// remember the current OS and EXE selections in the session, so that
// they'll stick if the user wants to download multiple games during
// this session
$_SESSION['download_adviser_state'] = "$osid.$osvsn.$noExes";

$qosid = mysql_real_escape_string($osid, $db);
$qosvsn = mysql_real_escape_string($osvsn, $db);
$os = "$osid.$osvsn";

// set up the relative file path converter function
$result = mysql_query(
    "select externid, name from operatingsystems where id='$qosid'", $db);
$urlToOsBody = 'return $s;';
$myosname = "(your operating system)";
if ($result && mysql_num_rows($result)) {
    $extid = mysql_result($result, 0, "externid");
    $myosname = mysql_result($result, 0, "name");
    if (isset($urlToOsMap[$extid])) {
        $urlToOsBody = $urlToOsMap[$extid];
    }
}
$urlToOs = create_function('$s', $urlToOsBody);


//$andOsVsn = ($osvsn == "" ? "" : "and osversions.vsnid = '$qosvsn'");
//$result = mysql_query(
//    "select
//        operatingsystems.name,
//        osversions.name
//     from operatingsystems
//        left outer join osversions
//          on osversions.osid = operatingsystems.id
//             and osversions.name != "*"
//     where
//        operatingsystems.id = '$qosid'
//        $andOsVsn", $db);
//list ($osname, $osvsnname) = mysql_fetch_row($result);
//if ($osvsnname)
//    $osname .= " $osvsnname";

// Get the list of download options for this game.
$result = mysql_query(
    "select
        gamelinks.title as title,
        gamelinks.`desc` as `desc`,
        gamelinks.url as url,
        (gamelinks.attrs & " . GAMELINK_IS_GAME . ") as isgame,
        gamelinks.fmtid as fmtid,
        filetypes.fmtname as fmtname,
        filetypes.`desc` as fmtdesc,
        filetypes.fmtclass as fmtclass,
        filetypes.externid as fmtexternid,
        gamelinks.osid as osid,
        gamelinks.osvsn as osvsn,
        osversions.seq as osseq,
        gamelinks.compression as compression,
        ftz.externid as compexternid,
        ftz.fmtname as compfmtname,
        gamelinks.compressedprimary as compressedprimary,
        gamelinks.displayorder as displayorder,
        operatingsystems.name as osname
     from
        gamelinks
        left outer join operatingsystems
          on operatingsystems.id = gamelinks.osid
        left outer join osversions
          on osversions.vsnid = gamelinks.osvsn
        left outer join filetypes as ftz
          on ftz.id = gamelinks.compression,
        filetypes
     where
        filetypes.id = gamelinks.fmtid
        and ifnull(operatingsystems.id, '$qosid') = '$qosid'
        and gameid = '$qid'", $db);

for ($links = array(), $i = 0 ; $i < mysql_num_rows($result) ; $i++) {
    // fetch the row
    $l = mysql_fetch_array($result, MYSQL_ASSOC);

    // remap the URL to the user's selected IF Archive mirror, if applicable
    $l['url'] = urlToMirror($l['url']);

    // add it to the list
    $links[] = $l;
}

// get the list of compression formats
$result = mysql_query(
    "select id, fmtname, `desc` from filetypes where fmtclass = 'Z'", $db);
for ($zips = array(), $i = 0 ; $i < mysql_num_rows($result) ; $i++) {
    $z = mysql_fetch_array($result, MYSQL_ASSOC);
    $zips[$z['id']] = $z;
}

// set up the basic re-query parameters, in case they ask for more options
$baseHref = "dladviser?id=$id&os=$os";

// Let's see if we have any game executables to offer.  If so, and
// if they haven't already nixed EXEs, tell them that we're going to
// offer EXEs and offer the nixing option.
$foundGameSetup = false;
$foundGameExe = false;
$foundStory = false;
foreach ($links as $l) {
    if ($l['isgame']) {
        $fc = $l['fmtclass'];
        $fx = $l['fmtexternid'];
        if ($fx == 'setup')
            $foundGameSetup = true;
        if ($fx == 'executable')
            $foundGameExe = true;
        if ($fc == 'G')
            $foundStory = true;
    }
}

// if we're in XML mode, and we have a story file version available,
// use the story file version instead of an executable version
if ($xml && $foundStory)
    $noExes = true;

// if we're in XML mode, and we found a non-installer game executable,
// use it instead of any installer
if ($xml && $foundGameExe)
    $noInstallers = true;

//$storyfile = "<a href=\"needjs\" onclick=\"javascript:helpWin("
//             . "'help-storyfile');return false;\">explain</a>";
$storyfile = helpWinLink("help-storyfile", "explain");

$notes = "";
if (($foundGameExe || $foundGameSetup) && !$noExes) {
    $notes = "<p><span class=details><i>";
    if ($foundStory)
        $notes .= "The instructions below are for the Application version
              of the game. <a href=\"$baseHref&noexes=1\">Click here</a>
              if you'd prefer the Story File version ($storyfile).";
    else
        $notes .= "The instructions below are for an Application download.
              There are no known Story File versions ($storyfile) of this
              game.";
    $notes .= "</i></span>";
}
if ($noExes && ($foundGameExe || $foundGameSetup) && $foundStory) {
    $notes .= "<p><span class=details><i>"
        . "The instructions below are for the Story File version of the "
        . "game ($storyfile). If you'd prefer the Application version, "
        . "<a href=\"$baseHref&noexes=0\">click here</a>."
        . "</i></span>";
}

// warn about viruses and other risks
$notes .= "<p><span class=details><i>"
          . "Before downloading files, please read our "
          . helpWinLink("help-dlsafety", "notes on download safety")
          . "</i></span>.";
//   . "Before downloading files, please read our "<a href=\"needjs\" "
//   . "onclick=\"javascript:helpWin('help-dlsafety');return false;\">"
//   . "notes on download safety</a></i></span>.";


// start the step-by-step tables - one for the human-readable instructions
// list, one for the XML list for the auto-installer
$helplist = array();
$xmllist = array();

// add an item to the help list
function addHelpList($v)
{
    global $helplist;

    if (is_array($v)) {
        foreach ($v as $vcur)
            addHelpList($vcur);
    }
    else if ($v)
        $helplist[] = collapseEmptyLists($v);
}

// Unroll any items in a list that consist of bare sublists into new
// top-level items.
function unrollTopSublists($lst)
{
    // start with an empty return list
    $ret = array();

    // process each item in the main list
    foreach ($lst as $item) {
        // get the first tag in this item
        list($tagofs, $ofs, $frag, $tag, $attrs) = findNextTag($item, 0);

        // if the first tag is <UL> or <OL>, and there's nothing but
        // whitespace before it, unroll the list as a set of top-level items
        $tag = strtolower($tag);
        if (($tag == "ol" || $tag == "ul")
            && !preg_match("/[^\s\n]/", $frag)) {

            // unroll this item - find each <LI> and turn it into a
            // separate top-level item

            for ($lsp = 0, $liTxt = "" ; ; ) {

                // find the next tag
                list($tagofs, $ofs, $frag, $tag, $attrs) =
                    findNextTag($item, $ofs);

                // add this fragment to the current <li> text
                $liTxt .= $frag;

                // if there are no more tags, shop out the last item,
                // and we're done
                if (!$tag) {
                    // ship out the last item if it's non-empty
                    if (preg_match("/[^\s\n]/", $liTxt))
                        $ret[] = $liTxt;

                    // we're done scanning the item
                    break;
                }

                // get the tag text
                $tagTxt = substr($item, $tagofs, $ofs - $tagofs);

                // check what we have
                switch (strtolower($tag)) {
                case 'ul':
                case 'ol':
                    // bump up the list nesting level
                    $lsp++;
                    $liTxt .= $tagTxt;
                    break;

                case '/ul':
                case '/ol':
                    // if we're in a nested tag, keep the close tag
                    if ($lsp != 0)
                        $liTxt .= $tagTxt;

                    // bump down the list nesting level
                    $lsp--;
                    break;

                case 'li':
                    // if this is in the top-level list, start a new item
                    if ($lsp == 0) {
                        // ship out the current text if it's non-empty as a
                        // new top-level item
                        if (preg_match("/[^\s\n]/", $liTxt))
                            $ret[] = $liTxt;

                        // start the next top-level item
                        $liTxt = "";
                    } else {
                        // we're in a nested list, so keep this as-is
                        $liTxt .= $tagTxt;
                        break;
                    }
                    break;

                default:
                    // keep this tag as-is
                    $liTxt .= $tagTxt;
                    break;
                }
            }
        }
        else {
            // keep this item intact - just add it directly
            $ret[] = $item;
        }
    }

    // return the new list
    return $ret;
}

// Collapse empty lists in a help list item.  We'll scan for items
// of the form <LI><UL> ... </UL>, and convert them to <LI>...<LI>...<LI>...
// lists instead - in other words, if a list occurs as the only thing
// within a list item, we'll convert the list to items directly in the
// enclosing list.
function collapseEmptyLists($msg)
{
    $listStack = array();
    $lsp = -1;

    // scan the string
    for ($ret = "", $ofs = 0, $liOfs = -1 ; ; ) {

        // find the next tag
        list($tagofs, $ofs, $frag, $tag, $attrs) = findNextTag($msg, $ofs);

        // add the plain text up to the tag to the output
        $ret .= $frag;

        // if we're out of tags, we're done
        if (!$tag)
            break;

        // get the full text of the tag
        $tagTxt = substr($msg, $tagofs, $ofs - $tagofs);

        // check what we have
        switch (strtolower($tag)) {
        case 'ul':
        case 'ol':
            // Opening a list.  If there's nothing significant in the output
            // between here and the last <li>, bump this sublist up to the
            // enclosing level.  To do this, we'll delete the <UL>/<OL>,
            // delete the next <LI>, and delete the matching </UL>/</OL>.
            // This will leave the remaining text as <LI> entries within
            // the enclosing list.
            if ($liOfs >= 0
                && !preg_match("/[^\s\n]/", $ret, $match, 0, $liOfs)) {
                // we have an <LI><UL> or <LI><OL> construct - bump the
                // sublist up to the enclosing list level
                $listStack[++$lsp] = array(true, 0);
            } else {
                // it's not a collapsable sublist, so keep it as-is
                $listStack[++$lsp] = array(false, 0);
                $ret .= $tagTxt;
            }
            break;

        case '/ul':
        case '/ol':
            // closing a list - pop the stack level
            $collapse = false;
            if ($lsp >= 0)
                list($collapse, $linum) = $listStack[$lsp--];

            // if we're not collapsing this list, keep the close tag
            if (!$collapse)
                $ret .= $tagTxt;

            break;

        case 'li':
            // Starting a list item.  If we're in a collapsing sublist,
            // and this is the first LI in the sublist, delete the <LI> -
            // we want to merge its contents into the enclosing list item.
            //
            // Otherwise, keep the list item and note its starting position
            // in the output.
            if ($lsp >= 0 && $listStack[$lsp][0] && $listStack[$lsp][1] == 0) {
                // this is the first <li> in a collapsing sublist - skip it,
                // and bump up the <li> count so we know we've passed the
                // first one
                $listStack[$lsp][1] += 1;
            } else {
                // this isn't a collapsing <li> - keep it in the output,
                // and note its location in the output
                $ret .= $tagTxt;
                $liOfs = strlen($ret);
            }
            break;

        default:
            // keep other tags as-is
            $ret .= $tagTxt;
            break;
        }
    }

    // return the result
    return $ret;
}

// open a help sublist level - this sets up a sublist that will capture
// subsequent addHelpList() items within a nested list
function openHelpSublist()
{
    global $helplist, $helpstack;

    // push the current help list onto the stack
    $helpstack[] = $helplist;

    // open up an empty sublist
    $helplist = array();
}

// Close the help sublist level - this closes the current list level,
// and returns the list of items added since the last openHelpSublist()
// call as a string.  The items are joined with "<li>" tags.
function closeHelpSublist()
{
    global $helplist, $helpstack;

    // turn the sublist into a string
    $ret = "<ul><li>" . implode("\n<li>", $helplist) . "\n</ul>\n";

    // pop the stack
    $helplist = array_pop($helpstack);

    return $ret;
}

// we haven't run into any missing instructions yet
$missing = "";

// If we have an OS version, get its sequence number in the full list of
// versions for the OS.  We're only interested in executables compatible
// with the user's system, which means that we only want executables for
// EARLIER versions of the OS.  We assume that an executable is compatible
// with all later versions of the same OS, so we're interested in exes
// with OS versions EARLIER than our target OS.
//
// If there's no OS version, we want to refer to the default all-versions
// entries for the OS, which always have sequence number 0.
if ($osvsn) {
    $result = mysql_query("select seq from osversions
        where osid = '$qosid' and vsnid = '$qosvsn'", $db);
    $osseq = mysql_result($result, 0, "seq");
    $andSeq = "and ifnull(osversions.seq,0) <= '$osseq'";
} else {
    $osseq = "0";
    $andSeq = "";
}

function sortByOsSeqDesc($a, $b)
{
    return $b['osseq'] - $a['osseq'];
}

function sortByDisplayOrder($a, $b)
{
    return $a['displayorder'] - $b['displayorder'];
}

define("STEP_DOTS", 1);

function startStep($flags)
{
    global $stepnum;

    $ret = "";

    // show a dotted line if desired
    if ($flags & STEP_DOTS)
        return "<tr><td colspan=2><hr class=dots>";

    // show the step number in the margin
    $ret .= "<tr valign=top><td align=center style=\"padding-right:1em;\">"
            . ($stepnum <= 9
               ? "<img src=\"img/blank.gif\" class=\"stepnum$stepnum\">"
               : "<b><font size=+1>$stepnum</font></b>")
            . "</td><td>";

    // consume this step number
    $stepnum++;

    // return the message string
    return $ret;
}

function endStep()
{
    return "</td></tr>";
}

// Substitute message parameters.  This looks for parameter tags of
// the form {xxx}.  {lb} is translated to "{" and {rb} to "}".
function substParams($msg, $params)
{
    for ($ofs = 0 ; $ofs < strlen($msg) ; $ofs++) {
        // find the next brace
        $ofs = strpos($msg, "{", $ofs);
        if ($ofs === FALSE)
            break;

        // find the close brace
        $endofs = strpos($msg, "}", $ofs+1);
        if ($endofs === FALSE)
            break;

        // get the parameter name
        $nm = substr($msg, $ofs + 1, $endofs - $ofs - 1);

        // look it up
        if ($nm == "lb")
            $val = "{";
        else if ($nm == "rb")
            $val = "}";
        else if (isset($params[$nm]))
            $val = $params[$nm];
        else
            continue;

        // substitute it
        $msg = substr_replace($msg, $val, $ofs, $endofs - $ofs + 1);

        // skip ahead to the end of the replacement text
        $ofs -= strlen($nm) + 2;
        $ofs += strlen($val) - 1;
    }

    // return the result;
    return $msg;
}

// Get the given message (specified by column name) for the current OS.
// We look for the message applicable to the current OS version, or to
// the highest previous version (i.e., we assume backward compatibility).
function getOsMessage($col, $params, $defmsg)
{
    global $db, $qosid, $osseq, $missing;

    // look up the message in the database
    $sql= "select $col, seq from osversions
           where osid='$qosid' and $col is not null and seq <= $osseq
           order by seq desc
           limit 0, 1";
    $result = mysql_query($sql, $db);
    if (mysql_num_rows($result) > 0)
        $msg = mysql_result($result, 0, $col);
    else
        $msg = $defmsg;

    // if there's no message and no default message, note that we
    // don't have sufficient data to generate the requested instructions
    if (!$msg)
        $missing .= "getOsMessage($col) ";

    // apply substitution parameters
    return substParams($msg, $params);
}

// Find the next HTML/XML-style tag in a run of text.  'txt' is the string
// to parse, and 'ofs' is the starting offset for parsing.
//
// Returns an array consisting of (tagofs, endofs, text_fragment, tag, attrs),
// where 'tagofs' is the offset of the tag we found, 'endofs' is the offset
// of the first character after the end of the tag, 'text_fragment' is the
// plain-text fragment between 'ofs' and the start of the tag; 'tag' is the
// tag name, and 'attrs' is a hash table keyed by attribute name giving the
// attribute values.
function findNextTag($txt, $ofs)
{
    // find the starting '<' of the next tag
    $tagofs = strpos($txt, '<', $ofs);

    // if we didn't find it, there aren't any more tags - just return the
    // rest of the string as plain text
    if ($tagofs === FALSE)
        return array(strlen($txt), strlen($txt),
                     substr($txt, $ofs), false, false);

    // we have a tag - get the fragment up to the tag and process it
    $frag = handleFragment(substr($txt, $ofs, $tagofs - $ofs));

    // skip ahead to the tag
    $ofs = $tagofs;

    // find the end of the tag - it's the next space or '>'
    if (preg_match("/[>\s]/", $txt, $match, PREG_OFFSET_CAPTURE, $ofs+1))
        $endofs = $match[0][1];
    else
        $endofs = strlen($txt);

    // pull out the tag name
    $tagofs = $ofs;
    $tag = substr($txt, $ofs + 1, $endofs - $ofs - 1);

    // parse attributes
    for ($ofs = $endofs, $attrs = array() ; ; )
    {
        // skip whitspace
        if (preg_match("/\S/", $txt, $match, PREG_OFFSET_CAPTURE, $ofs))
            $ofs = $match[0][1];

        // if we're at '>' or end of string, we're done
        if ($ofs >= strlen($txt)) {
            break;
        } else if ($txt{$ofs} == '>') {
            $ofs++;
            break;
        }

        // we're at an attribute - find the end of its name
        if (preg_match("/[=\s>]/", $txt, $match, PREG_OFFSET_CAPTURE, $ofs))
            $endofs = $match[0][1];
        else
            $endofs = strlen($txt);

        // pull out the attribute name
        $attrName = substr($txt, $ofs, $endofs - $ofs);

        // if we're at an '=', get the value
        $ofs = $endofs;
        if ($ofs < strlen($txt) && $txt{$ofs} == '=') {
            // there's a value - check for quotes
            $ofs++;
            if ($txt{$ofs} == '"' || $txt{$ofs} == '\'') {
                // skip the open quote
                $ofs++;

                // find the close quote
                $endofs = strpos($txt, $txt{$ofs-1}, $ofs);
                if ($endofs === false)
                    $endofs = strlen($txt);

                // pull out the message
                $attrVal = substr($txt, $ofs, $endofs - $ofs);

                // skip the close quote
                $ofs = $endofs + 1;
            } else {
                // no quotes - the value ends at the next space or '>'
                if (preg_match("/[>\s]/", $txt, $match,
                               PREG_OFFSET_CAPTURE, $ofs))
                    $endofs = $match[0][1];
                else
                    $endofs = strlen($txt);

                // pull out the value
                $attrVal = substr($txt, $ofs, $endofs - $ofs);

                // skip past the value
                $ofs = $endofs;
            }
        } else {
            // no explicit value; use "1" as the default value
            $attrVal = "1";
        }

        // save this value
        $attrs[$attrName] = $attrVal;
    }

    // return the results
    return array($tagofs, $ofs, $frag, $tag, $attrs);
}

// Handle a message fragment in getFormatMessage - this returns the text
// to add to the output message under construction.
function handleFragment($frag)
{
    return $frag;
}

// Process #include directives in the download help
function processIncludes($str, $col)
{
    global $db;

    // canonicalize newlines
    $str = str_replace(array("\r\n", "\r"), array("\n", "\n"), $str);

    // turn it into an array of lines
    $arr = explode("\n", $str);

    // process each #include directive
    for ($i = 0 ; $i < count($arr) ; $i++) {
        $l = $arr[$i];
        if (substr($l, 0, 9) == "#include ") {
            // parse the include directive - it's OSID.OSVSNID.FMTID
            list($osid, $vsnid, $fmtid) = explode('.', trim(substr($l, 9)));
            $qosid = mysql_real_escape_string($osid, $db);
            $qvsnid = mysql_real_escape_string($vsnid, $db);
            $qfmtid = mysql_real_escape_string($fmtid, $db);

            // look up this record
            $sql =
                "select
                   downloadhelp.$col as txt
                 from
                   downloadhelp, operatingsystems, osversions, filetypes
                 where
                   operatingsystems.externid = '$qosid'
                   and osversions.externid = '$qvsnid'
                   and filetypes.externid = '$qfmtid'
                   and downloadhelp.osid = operatingsystems.id
                   and downloadhelp.osvsnid = osversions.vsnid
                   and downloadhelp.fmtid = filetypes.id";
            $result = mysql_query($sql, $db);
            if (mysql_num_rows($result) > 0)
                $arr[$i] = mysql_result($result, 0, "txt");
        }
    }

    // turn it back into a string and return the result
    return implode("\n", $arr);
}

// Get the given column from the download help record for the given
// format for the current OS.  We'll look for an entry for the format
// matching the OS, with a version less than or equal to the current
// OS version (i.e., we assume backward compatibility).
function getFormatHelp($fmtid, $col)
{
    global $db, $qosid, $osseq;

    // look up the message in the database
    $qfmtid = mysql_real_escape_string($fmtid, $db);
    $sql = "select
              downloadhelp.$col as $col,
              osversions.seq,
              if(downloadhelp.osid = 1, 1, 0) as orderkey
            from
              downloadhelp, osversions
            where
              downloadhelp.fmtid = '$qfmtid'
              and downloadhelp.osvsnid = osversions.vsnid
              and
                ((downloadhelp.osid = '$qosid' and osversions.seq <= $osseq)
                 or downloadhelp.osid = 1)
              and downloadhelp.$col is not null
            order by
              orderkey, osversions.seq desc
            limit
              0, 1";
    $result = mysql_query($sql, $db);

    // if we found an entry, return it
    if (mysql_num_rows($result) > 0)
        return processIncludes(mysql_result($result, 0, $col), $col);
    else
        return false;
}

// Get the given human-readable message (specified by column name) for
// the given format for the current OS, formatted for display.
function getFormatMessage($fmtid, $col, $params)
{
    global $db, $qosid, $osseq, $missing, $zips;

    // we don't have anything to return yet
    $ret = "";

    // look up the raw message
    $msg = getFormatHelp($fmtid, $col);

    // if we didn't find anything, note that we don't have enough information
    // to generate the requested instructions
    if (!$msg)
        $missing .= "getFormatMessage(fmtid=$fmtid, $col) ";

    // apply substitution parameters
    $msg = substParams($msg, $params);

    // remove leading and trailing spaces
    $msg = trim($msg);

    // process our special tags - <run>, <download>...
    for ($ofs = 0 ; ; ) {

        // find the next tag
        list($tagofs, $ofs, $frag, $tag, $attrs) = findNextTag($msg, $ofs);

        // add the plain text up to the tag to the output
        $ret .= handleFragment($frag);

        // if there are no more tags, we're done */
        if (!$tag)
            break;

        // check which tag we have
        switch (strtolower($tag)) {
        case 'download':
            // <download>: displays the instructions for downloading
            // a file from a hyperlink.
            //
            // Attributes:
            //
            //    href="url" - the URL of the file to download
            //
            //    localref="file" - the local filename of the downloaded
            //          file (for situations like "http://domain/php?params",
            //          where the filename part can't be deduced directly
            //          from the URL)
            //
            //    compression="zip" - the file to be downloaded is
            //          compressed with the given format; add suitable
            //          instructions for the format as top-level steps
            //          preceding this step
            //
            //    run="filename" - if present, we give instructions to
            //          run the file after downloading it.  If "filename"
            //          is present, we'll run that local file, which is
            //          something extracted from a compressed archive;
            //          otherwise we'll run the same file we downloaded.
            //

            // if there's a compression format, look it up by external ID
            $compfmt = "";
            if (isset($attrs['compression'])) {
                $compfmt = mysql_real_escape_string(
                    $attrs['compression'], $db);
                $result = mysql_query(
                    "select id from filetypes
                     where externid = '$compfmt'", $db);
                if (mysql_num_rows($result))
                    $compfmt = mysql_result($result, 0, "id");
            }

            // look up the instruction
            $ret .= handleFragment(getDownloadURLInstructions(
                $attrs['href'], $attrs['localref'], $compfmt, $attrs['run'],
                isset($attrs['run'])));
            break;

        default:
            // anything else is just plain HTML - don't handle it as
            // a tag after all; just keep it exactly as-is
            $ret .= handleFragment(substr($msg, $tagofs, $ofs - $tagofs));
            break;
        }
    }

    // return the result
    return $ret;
}

// given a URL, get the base filename
function urlBaseName($url)
{
    $prsurl = parse_url($url);
    return basename($prsurl['path']);
}

// Given link data, get the local filename.  If the link refers to an
// uncompressed file, the local filename is simply the root name from
// the URL.  If it's a compressed file, it's the name given in the
// 'compressedprimary' field of the link.  If that field is empty,
// we'll show the compressed file as the filename, but add a footnote
// that the user has to figure out which extracted file is relevant.
function localFileFromLink($url, $compressed, $localfile)
{
    // assume we won't need a footnote
    $footnote = "";

    // check for compression
    if ($compressed) {
        // it's compressed - use the explicit local file, if present
        $fname = $localfile;
        if ($fname == "") {
            // there's no explicit primary file, so use a fake name, and
            // add a footnote warning that it's not really the right file
            $fname = preg_replace("/\\.[^.]+$/", "", urlBaseName($url));
            $fname = "<span class=errmsg>"
                     . strtoupper($fname) . ".XXX*</span>";
            $footnote = "<p><span class=details><span class=errmsg>* <i>"
                        . "Substitute the appropriate file that you "
                        . "unpacked from the compressed archive earlier. "
                        . "We'd tell you the exact name, but that "
                        . "information isn't in our database."
                        . "</i></span></span>";
        } else {
            $fname .= "<span class=errmsg>*</span>";
            $footnote = "<p><span class=details><span class=errmsg>*</span> "
                        . "<i>This is one of the files you unpacked from "
                        . htmlspecialcharx(urlBaseName($url))
                        . " above.</i></span>";
        }
    } else {
        // it's uncompressed - simply use the root name from the URL
        $fname = urlBaseName($url);
    }

    // return the filename and any footnote
    return array($fname, $footnote);
}

// explain how to run the local file that you get from a download
function sayLocalRun($url, $comp, $localfile)
{
    // get the local filename from the link
    list($fname, $footnote) = localFileFromLink($url, $comp, $localfile);

    // generate and add the OS message
    addHelpList(getOsMessage("runinstructions",
                             array("fname" => $fname),
                             "Run the program file {fname}.")
                . $footnote);
}

// explain how to download the player app associated with the given format
function sayFormatDownload($fmtid)
{
    // build the message for installing the format player/viewer app
    addHelpList(getFormatMessage($fmtid, "dlinstructions", array()));
}

// explain how to run the player app associated with the given format,
// invoking it on the given LOCAL file
function sayFormatRun($fmtid, $l, $fname)
{
    global $urlToOs, $title;

    // get the file to run based on the link, if provided in that form
    $footnote = "";
    if ($l)
        list($fname, $footnote) = localFileFromLink(
            $l['url'], $l['compression'],
            $urlToOs($l['compressedprimary']));

    // build the message for running the format app on the given file
    addHelpList(getFormatMessage($fmtid, "runinstructions",
                                 array("fname" => $fname, "title" => $title))
                . $footnote);
}

// we haven't yet showed the generic download instructions for the OS
$showedDlInstructions = 0;
$showedDlRunInstructions = 0;

// Get the general instructions for downloading a file using the browser.
// We only show these instructions the first time they're requested; after
// that, we assume that they'd be redundant, since the user just saw them
// on an earlier step on the same page.
function getDlInstructions($run)
{
    global $showedDlInstructions, $showedDlRunInstructions;

    // if we've already shown these instructions, skip them this time
    if ($run) {
        if ($showedDlRunInstructions++)
            return;
    } else {
        if ($showedDlInstructions++)
            return;
    }

    // start the NOTES span
    $ret = "<br><div class=indented><span class=notes><i>";

    // add the appropriate instructions
    if ($run)
        $ret .= getOsMessage(
            "dlruninstructions", array(),
            "In most browsers, right-click on the link and
             select <b>Open</b> or <b>Run</b> from the menu.");
    else
        $ret .= getOsMessage(
            "dlinstructions", array(),
            "In most browsers, right-click on the link and
             select <b>Save</b> from the menu, then follow
             your browser's instructions to choose a destination
             folder for the downloaded file.");

    // end the span
    $ret .= "</i></span></div>";

    // return the instructions
    return $ret;
}

// Get the human-readable instructions for downloading a URL.  This might
// involve multiple steps, so we return an array of strings with the
// individual steps.
function getDownloadURLInstructions($url, $localref, $comp, $localfile, $run)
{
    global $zips;

    // map the URL to the user's IF Archive preferred mirror, if applicable
    $url = urlToMirror($url);

    // get the download location
    $hrefurl = str_replace(array('"'), array("%22"), $url);
    $dispurl = htmlspecialcharx($url);
    $displink = "<a href=\"$hrefurl\">$dispurl</a>";

    // check for compression
    if ($comp) {

        // we have compression - we need to download the unarchiver
        $z = $zips[$comp];
        if ($z) {

            // If we haven't already covered downloading the archiver,
            // do so now.  Add this as a separate, out-of-band top-level
            // step, since it's a pre-requisite rather than part of the
            // download/install process for the current item.
            if (!isset($z['-done-'])) {
                // show the help for downloading the archiver
                sayFormatDownload($comp);

                // note that we've handled this archiver, in case it
                // comes up again for a later file
                $zips[$comp]['-done-'] = true;
            }

            // open a sublist for the multi-step process of downloading
            // the archive, unpacking the contents, and possibly running
            // an extracted file
            openHelpSublist();

            // add a step to download the file
            addHelpList("Download and save this file: $displink"
                        . getDlInstructions(false));

            // Get the default local name of the downloaded file.  This
            // can usually be deduced as the base name from the URL, but
            // we also let the caller specify it explicitly, for cases
            // such as "http://domain/php?params...", where the filename
            // is hidden in the parameters or simply isn't there at all.
            // So, if the caller specified an explicit "localref", use
            // that; otherwise use the base name from the URL.
            $fname = ($localref != "" ? $localref : urlBaseName($url));

            // show the help for decompressing the archive
            sayFormatRun($comp, null, $fname);

            // if we're meant to run the extracted program, say so
            if ($run)
                sayLocalRun($url, $comp, $localfile);

            // the result is the sublist
            $ret = closeHelpSublist();

        } else {
            // this should never happen - we're missing the compression
            // format record
            $ret = "<span class=errmsg>The following file is identified
                    in the database as compressed, but we don't have any
                    information on the format:</span>
                    <p>$displink";
        }
    }
    else {

        // no compression - we can download in a single step
        $ret = "Download and " . ($run ? "run" : "save") . " this file: "
               . $displink
               . getDlInstructions($run);
    }

    // return the instructions
    return $ret;
}

function sayDownloadLink($link, $run)
{
    global $urlToOs;

    // get the parameters from the link
    $url = $link['url'];
    $comp = $link['compression'];
    $local = $urlToOs($link['compressedprimary']);

    // downloading the URL
    addHelpList(getDownloadURLInstructions($url, "", $comp, $local, $run));
}

// Okay, let's figure out how to play this game.  Start the display at
// step number 1.
$stepnum = 1;
$storyDone = false;

// Remove any links that have compression formats that we can't handle.
// This will prevent picking a package and then failing because it's
// in the wrong compression format, when we would have succeeded if we'd
// just picked one of the other formats.
function filterByCompression($l)
{
    // we can always handle an uncompressed file
    $compr = $l['compression'];
    if ($compr == "")
        return true;

    // it's compressed, so the question is whether we handle this format:
    // we do if there's help for it
    return (getFormatHelp($compr, "dlinstructions") != false
            && getFormatHelp($compr, "runinstructions") != false);
}
$allLinks = $links;
$links = array_filter($links, "filterByCompression");
$xmlGameLink = false;

// First, see if there's a stand-alone executable for this platform.
// Skip this step if they've specifically said they don't want to install
// stand-alone executables.
if (!$noExes && !$noInstallers) {

    // Look for an executable installer format - format class "X" for
    // executable, type ID "Inst" for installer - for our OS.
    // We want the latest compatible version, so we want the one with the
    // highest osseq if we find more than one.
    usort($links, "sortByOsSeqDesc");
    foreach ($links as $l) {
        if ($l['fmtexternid'] == 'setup' && $l['isgame']) {
            // download and run this file
            sayDownloadLink($l, true);

            // note this as the XML Meta Installer download
            $xmlGameLink = $l;

            // add a step about following the SETUP instructions
            addHelpList(
                "Follow the installation program's instructions.  When it's
                finished, the game will be installed on your system, and you
                can run it like any other program.");

            // we're finished installing the story
            $storyDone = true;

            // no need to look any further - we just want to display the one
            break;
        }
    }
}

// If we're not done yet, look for a stand-alone executable game -
// format class "X" for executable, type ID "Game".  We want the
// same sorting order for this as we did for the installer, so we
// can simply scan the same list again for our new target.
if (!$noExes && !$storyDone) {
    foreach ($links as $l) {
        if ($l['fmtexternid'] == 'executable' && $l['isgame']) {
            // download the file
            sayDownloadLink($l, false);

            // note this as the XML Meta Installer download
            $xmlGameLink = $l;

            // explain that they simply need to run this downloaded file
            // each time they want to play the game
            sayLocalRun($l['url'], $l['compression'],
                        $urlToOs($l['compressedprimary']));

            // we're finished installing the story
            $storyDone = true;

            // no need to look any further
            break;
        }
    }
}

// If we haven't installed anything yet, look for the Story File version.
// Find the first one in display order, EXCEPT that we'll skip compressed
// files without stated primaries IF we have either a compressed file with
// a stated primary OR an uncompressed story file.  The unstated primary
// makes for bad instructions, since we can't say precisely what to do
// after unzipping the archive, so skip these if we have a better option.
usort($links, "sortByDisplayOrder");
$foundPri = false;
foreach ($links as $l) {
    if ($l['fmtclass'] == 'G' && $l['isgame']
        && (($l['compression'] != "" && $l['compressedprimary'] != "")
            || $l['compression'] == "")) {
        $foundPri = true;
        break;
    }
}
if (!$storyDone) {
    foreach ($links as $l) {
        if ($l['fmtclass'] == 'G' && $l['isgame']) {

            // if this is a compressed file without a primary, AND we have
            // a better option elsewhere in the list, skip this one so
            // that we continue on to the better option
            if ($l['compression'] != "" && $l['compressedprimary'] == ""
                && $foundPri)
                continue;

            // explain how to get the player
            sayFormatDownload($l['fmtid']);

            // download the file
            sayDownloadLink($l, false);

            // note this as the XML Meta Installer download
            $xmlGameLink = $l;

            // explain how to run it
            sayFormatRun($l['fmtid'], $l, null);

            // we found the story
            $storyDone = true;

            // there should only be one story file to install
            break;
        }
    }
}

// Pick a story file for XML download.  For this, take the first playable
// file that shows up in display order.  (See below for old algorithm.)
function sortForXmlStoryPick($a, $b)
{
    return sortByDisplayOrder($a, $b);
}
//
// --- OLD XML STORY FILE SELECTION ALGORITHM ---
// We formerly sorted compressed formats (ZIP, tar, etc) ahead of plain
// story files, on the theory that a compressed archive probably contained
// bundled extras that the player might want.  Unfortunately, there are
// some games where this approach didn't work so well, such as a game with
// the original version as a plain .z5 file and a translated version in
// a ZIP file - our algorithm would pick the translated version.  So we now
// use the dead simple approach of picking the first playable file.
//
//$zipXmlOrder = array(
//    'zip' => 1, 'tar.Z' => 2, 'tar.gz' => 2, 'tar' => 3,
//    'stuffit' => 4, 'sit.bin' => 4, 'sit.hqx' => 5);
//
//function sortForXmlStoryPick($a, $b)
//{
//    global $zipXmlOrder;
//
//    // get the compression formats
//    $compa = $a['compexternid'];
//    $compb = $b['compexternid'];
//
//    // if one is compressed and the other isn't, take the compressed one
//    // over the uncompressed one
//    if ($compa != "" && $compb == "")
//        return -1;
//    else if ($compa == "" && $compb != "")
//        return 1;
//
//    // if both are compressed, go by compression preference order
//    if ($compa != "" && $compb != "")
//    {
//        $orda = (isset($zipXmlOrder[$compa]) ? $zipXmlOrder[$compa] : 100);
//        $ordb = (isset($zipXmlOrder[$compb]) ? $zipXmlOrder[$compb] : 100);
//        if ($orda != $ordb)
//            return $orda - $ordb;
//    }
//
//    // we don't have a compression preference, so sort by display order
//    return sortByDisplayOrder($a, $b);
//}
// --- end old XML story file selection algorithm ---
if ($xml) {
    usort($links, "sortForXmlStoryPick");
    foreach ($links as $l) {
        if ($l['fmtclass'] == 'G' && $l['isgame']) {
            $xmlGameLink = $l;
            break;
        }
    }
}

// Mention any auxiliary files; show these in the regular display order,
// and go back to the full set of links (not the subset that we filtered
// for compression compatibility - since we don't generate instructions
// for unzipping aux files, it doesn't matter whether we know the format
// or not, so better to leave this up to the user).
$links = $allLinks;
usort($links, "sortByDisplayOrder");
$auxCnt = 0;
$xmlExtras = "";
foreach ($links as $l) {
    if (!$l['isgame']) {
        $auxCnt++;
    }
}
if ($auxCnt > 0) {
    addHelpList("<dots>");

    $ns = ($auxCnt == 1 ? "" : "s");
    $vs = ($auxCnt == 1 ? "s" : "");
    $is = ($auxCnt == 1 ? "is" : "are");
    $thisfile = ($auxCnt == 1 ? "this file" : "any of these");
    $it = ($auxCnt == 1 ? "it" : "them");
    $s = "Optional extras: The following file$ns {$is}n't needed to play "
         . "the game, but offer$vs additional information or other "
         . "enhancements. If you'd like to download $thisfile, simply "
         . "save $it to the same folder location as the game files."
         . "<div class=indented>";

    foreach ($links as $l) {
        if (!$l['isgame']) {
            $url = $l['url'];
            $hrefurl = str_replace(array('"'), array("%22"), $url);
            $dispurl = htmlspecialcharx($url);
            $fmtname = htmlspecialcharx($l['fmtname']);
            $fmtdesc = $l['fmtdesc'];
            $fmtext = $l['fmtexternid'];
            $cmpext = $l['compexternid'];
            $cmpname = $l['compfmtname'];
            $cmppri = htmlspecialcharx($l['compressedprimary']);
            $linktitle = htmlspecialcharx($l['title']);
            $linkdesc = $xmldesc = htmlspecialcharx($l['desc']);
            $fmtdesc = ($fmtdesc == "" ? "" : "($fmtdesc)");
            if ($linkdesc != "")
                $linkdesc .= "<br>";
            $s .= "<p><a href=\"$hrefurl\">$linktitle</a>"
                  . "<div class=indented><span class=details>"
                  . "$linkdesc</span>"
                  . "<span class=fmtnotes>$fmtdesc</span>"
                  . "</span></div>";

            $xmlCompr = "";
            if ($l['compression']) {
                if ($cmppri)
                    $cmppri .= "<primaryfile>$cmppri</primaryfile>";
                $xmlCompr = "<compression>"
                            .  "<id>$cmpext</id>"
                            .  "<name>$cmpname</name>"
                            .  $cmppri
                            . "</compression>";
            }

            $xmlExtras .= "<extra>"
                          .  "<href>$dispurl</href>"
                          .  "<title>$linktitle</title>"
                          .  "<desc>$xmldesc</desc>"
                          .  "<formatid>$fmtext</formatid>"
                          .  $xmlCompr
                          . "</extra>";
        }
    }

    $s .= "</div>";

    addHelpList($s);
}

// if we're in XML mode, send the XML results
if ($xml) {

    // get the game download URL
    $gameUrl = htmlspecialcharx(urlToMirror($xmlGameLink['url']));

    // get the compression information
    if ($xmlGameLink['compression']) {

        $fmtid = $xmlGameLink['compexternid'];
        $fmtname = $xmlGameLink['compfmtname'];

        if ($xmlGameLink['compressedprimary']) {
            $pri = "<primaryfile>"
                   . htmlspecialcharx($xmlGameLink['compressedprimary'])
                   . "</primaryfile>";
        }
        else
            $pri = "";

        // assemble the XML for the compression format
        $gameCompr = "<compression>"
                     . "<id>$fmtid</id>"
                     . "<name>$fmtname</name>"
                     . "$pri"
                     . "</compression>";

    } else {
        // no compression
        $gameCompr = "";
    }

    // build the format information for the interpreter, if any
    $fmtInstall = $fmtDesc = "";
    if ($xmlGameLink['fmtexternid'] == 'setup') {

        // game installer
        $fmtType = "installer";

        // the format is simply "executable" in this case
        $fmtDesc = "<id>executable</id>";

    } else if ($xmlGameLink['fmtexternid'] == 'executable') {

        // game program
        $fmtType = "storyprogram";

        // the format is simply "executable" in this case
        $fmtDesc = "<id>executable</id>";

    } else if ($xmlGameLink['fmtclass'] == 'G') {

        // interpreter-based story file
        $fmtType = "storyfile";

        // get the <interpreter> help records for the format
        $fmtInstall = getFormatHelp($xmlGameLink['fmtid'], "installer");
        if (!$fmtInstall)
            $missing = true;

        // build the format description
        $fmtid = $xmlGameLink['fmtexternid'];
        $fmtname = $xmlGameLink['fmtname'];
        $fmtDesc = "<id>$fmtid</id>"
                   . "<name>$fmtname</name>";
    }

    // if we had any missing instructions, send an error reply
    if ($missing) {
        errorPage("NO INSTRUCTIONS", "Incomplete or Missing Instructions",
                  "Sorry, but IFDB doesn't have the information needed "
                  . "to install this game on your system.  This doesn't "
                  . "necessarily mean that you can't play this game on your "
                  . "computer; it's just that IFDB can't install it "
                  . "automatically.  You might still be able to install "
                  . "the game manually - check the Download box "
                  . "to see the available formats.");
    }

    // set up the XML response
    $xml = "";

    // add the IF Archive mirror setting, if available
    if ($mirrorUrlPref)
        $xml .= "<ifarchivemirror>$mirrorUrlPref</ifarchivemirror>";

    // add the game data
    $xml .= "<tuid>$id</tuid>"
            . "<ifids>$ifidsXml</ifids>"
            . "<version>$version</version>"
            . "<title>$title</title>"
            . "<author>$author</author>"
            . "<download>"
            .   "<game>"
            .     "<href>$gameUrl</href>"
            .     $gameCompr
            .     "<type>$fmtType</type>"
            .     "<format>"
            .       $fmtDesc
            .       $fmtInstall
            .     "</format>"
            .   "</game>"
            .   $xmlExtras
            . "</download>";

    // send the XML instructions
    sendXml($xml);

    // that's all for the XML version - we're done
    exit();
}

// we're not in XML mode - send the human-readable instructions
pageHeader("$title - Download Adviser");

// start the page
echo "<h1>Download Adviser for <i>$title</i></h1>"
   . "<p><a href=\"viewgame?id=$id\">Return to the game's home page</a>"

   . "<p><form method=\"get\" action=\"dladviser\" name=\"changeOS\">"
   . "<input type=hidden name=\"id\" value=\"$id\">"
   . "<input type=hidden name=\"noexes\" value=\"$noExes\">"

   . "<span class=details>Show instructions for: </span>";
    showOSPopup($db, "os", $os, 0);
    echo " <input type=image src=\"/img/blank.gif\" name=\"setOS\" "
        . "class=\"go-button\" id=\"dla-setos-2\">"
        . "</form>";

// If we ran into any missing instructions, explain that we can't generate
// the requested advice.  Otherwise, we were successful, so display the
// advice.
if ($missing) {
    // explain the problem
    echo "\n\n<!-- $missing -->\n\n";
    echo "<h2>Sorry!</h2>"
        . "Unfortunately, IFDB doesn't currently have instructions for "
        . "playing this game on your operating system. ";

    $otheropts = array();

    // check for a game-specific web site
    $result = mysql_query("select title, website from games
        where id='$qid'", $db);
    $url = mysql_result($result, 0, "website");
    if ($url) {
        $url = urlToMirror($url);
        $hrefurl = str_replace(array('"'), array("%22"), $url);
        $dispurl = htmlspecialcharx($url);
        $title = htmlspecialcharx(mysql_result($result, 0, "title"));
        $otheropts[] =
            "the Web site for <i>$title</i>, "
            . "<a href=\"$hrefurl\">$dispurl</a>";
    }

    // look for a game-file format among the links
    foreach ($links as $l) {
        if ($l['fmtclass'] == 'G' && $l['isgame']) {
            // look up the format to see if it has an associated web site
            $qfmtid = mysql_real_escape_string($l['fmtid'], $db);
            $result = mysql_query("select website from filetypes
                where id = '$qfmtid'", $db);
            $url = mysql_result($result, 0, "website");
            if ($url) {
                $url = urlToMirror($url);
                $hrefurl = str_replace(array('"'), array("%22"), $url);
                $dispurl = htmlspecialcharx($url);
                $otheropts[] =
                    "the Web site for the game's authoring system, "
                    . "<a href=\"$hrefurl\">$dispurl</a>";

                // we only want to do this for one file, so stop looking
                break;
            }
        }
    }

    if (count($otheropts)) {
        echo "<p>You might be able to find more information by visiting ";
        if (count($otheropts) == 1) {
            echo "{$otheropts[0]}.";
        } else {
            echo "one of the following:<p><ul>";
            foreach ($otheropts as $o)
                echo "<li>$o";
            echo "</ul>";
        }
    }

} else {
    // show any preliminary notes
    echo $notes;

    // start the table for the step list
    echo "<br><br><br>"
        . "<table class=dlinst border=0 cellspacing=0 cellpadding=0>";

    // unroll any steps that consist purely of sublists into separate steps
    $helplist = unrollTopSublists($helplist);

    // show the help message list
    foreach ($helplist as $h) {
        if ($h == "<dots>")
            echo startStep(STEP_DOTS) . endStep();
        else if ($h != "<skip>" && $h != "")
            echo startStep(0) . $h . endStep();
    }

    // if it's empty, explain
    if (count($helplist) == 0)
    {
        $forums = "<a href=\"http://www.intfiction.org/forum/\">intfiction.org forums</a>";

        // Special case: check to see if we have an executable for a different
        // operating system or systems.
        $result = mysql_query(
            "select
               distinct operatingsystems.name as osname
             from
               gamelinks
               left outer join operatingsystems
                 on operatingsystems.id = gamelinks.osid
               left outer join filetypes as ftz
                 on ftz.id = gamelinks.compression,
               filetypes
             where
               filetypes.id = gamelinks.fmtid
               and filetypes.externid = 'executable'
               and gameid = '$qid'", $db);
        for ($exeLinks = array(), $i = 0 ; $i < mysql_num_rows($result) ; $i++)
            $exeLinks[] = mysql_fetch_array($result, MYSQL_ASSOC);

        if (count($exeLinks) != 0)
        {
            if (count($exeLinks) == 1) {
                $fpro = "this system";
                $fthat = "that system";
                $app = "this app";
                $foreign = $exeLinks[0]['osname'];
                $emuSearch = "\"$foreign emulator for $myosname\"";
            }
            else {
                $emuSearch = "(for example) \"{$exeLinks[0]['osname']} emulator for $myosname\"";
                $fpro = "these systems";
                $fthat = "one of those systems";
                $app = "one of these apps";
                $foreign = array();
                foreach ($exeLinks as $e) {
                    $foreign[] = $e['osname'];
                }
                if (($c = count($foreign)) > 2)
                    $foreign[$c-1] = "and " . $foreign[$c-1];
                $foreign = implode(", ", $foreign);
            }

            echo "This game appears to be available only as a native application for "
                . "$foreign.  To run this game, you'll need to find a computer "
                . "that runs $fthat.  Alternatively, it might be possible to use "
                . "a \"virtual machine\" environment or emulator on your computer "
                . "to run $app, but that requires technical expertise that's beyond "
                . "what we can offer here.  Try a Web search for {$emuSearch}, "
                . "or try asking on the {$forums}.";
        }
        else
            echo "Sorry, but IFDB doesn't have any information about how to "
                . "run this game on your system.  You might try contacting the "
                . "game's author, or asking for help on the {$forums}.";
    }

    // end the table
    echo "</table>";
}

echo "<br><br><br>"
   . "<a href=\"help-dla\">Wrong instructions? Curious how this works?</a><br>"
   . "<a href=\"viewgame?id=$id\">Return to the game's home page</a><p>";

pageFooter();
?>
